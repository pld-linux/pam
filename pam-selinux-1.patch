diff -urN pam-pld-0.77.3.org/configure.in pam-pld-0.77.3/configure.in
--- pam-pld-0.77.3.org/configure.in	2003-12-27 01:14:06.000000000 +0100
+++ pam-pld-0.77.3/configure.in	2003-12-27 03:27:48.069612592 +0100
@@ -282,6 +282,8 @@
 	AC_MSG_WARN(pam_cap module will not be built!))
 AC_CHECK_LIB(opie, opieverify, opielib_present=true,
 	AC_MSG_WARN(pam_opie modules will not be built!))
+AC_CHECK_LIB(selinux, getfilecon, selinux_present=true, 
+	AC_MSG_WARN(SELinux support will not be enabled. pam_selinux and pam_selinux_check module will not be built!))
 AC_MSG_CHECKING(for hosts_access in -lwrap)
 oldLIBS=$LIBS
 LIBS="$LIBS -lwrap"
@@ -301,6 +303,7 @@
 AM_CONDITIONAL(CAPLIB_PRESENT, test x$caplib_present = xtrue)
 AM_CONDITIONAL(WRAPLIB_PRESENT, test x$wraplib_present = xtrue)
 AM_CONDITIONAL(OPIELIB_PRESENT, test x$opielib_present = xtrue)
+AM_CONDITIONAL(SELINUX_PRESENT, test x$selinux_present = xtrue)
 AC_DEFINE(HAVE_CRACKLIB)
 
 AC_MSG_CHECKING([where cracklib_dict is located])
diff -urN pam-pld-0.77.3.org/modules/pam_unix/lckpwdf.-c pam-pld-0.77.3/modules/pam_unix/lckpwdf.-c
--- pam-pld-0.77.3.org/modules/pam_unix/lckpwdf.-c	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/lckpwdf.-c	2003-12-27 01:14:20.000000000 +0100
@@ -26,6 +26,9 @@
 
 #include <fcntl.h>
 #include <signal.h>
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#endif
 
 #define LOCKFILE "/etc/.pwd.lock"
 #define TIMEOUT 15
@@ -64,6 +67,28 @@
 	if (lockfd != -1)
 		return -1;
 
+#ifdef WITH_SELINUX
+	if(is_selinux_enabled())
+	{
+		lockfd = open(LOCKFILE, O_WRONLY);
+		if(lockfd == -1 && errno == ENOENT)
+		{
+			security_context_t create_context;
+			int rc;
+
+			if(getfilecon("/etc/passwd", &create_context))
+				return -1;
+			rc = setfscreatecon(create_context);
+			freecon(create_context);
+			if(rc)
+				return -1;
+			lockfd = open(LOCKFILE, O_CREAT | O_WRONLY, 0600);
+			if(setfscreatecon(NULL))
+				return -1;
+		}
+	}
+	else
+#endif
 	lockfd = open(LOCKFILE, O_CREAT | O_WRONLY, 0600);
 	if (lockfd == -1)
 		return -1;
diff -urN pam-pld-0.77.3.org/modules/pam_unix/Makefile.am pam-pld-0.77.3/modules/pam_unix/Makefile.am
--- pam-pld-0.77.3.org/modules/pam_unix/Makefile.am	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/Makefile.am	2003-12-27 03:33:35.157847160 +0100
@@ -9,10 +9,18 @@
 modulesdir		= /lib/security
 sbindir			= /sbin
 
+if SELINUX_PRESENT
+LIBSELINUX              = -lselinux
+LIBSELINUX_DEFS		= -DWITH_SELINUX=1
+else
+LIBSELINUX              =
+LIBSELINUX_DEFS		=
+endif
+
 AM_CPPFLAGS = -DCHKPWD_HELPER=\"$(sbindir)/$(sbin_PROGRAMS)\" \
 			  -I$(top_srcdir)/include \
 			  -I$(top_srcdir)/pamcrypt/include
-pam_unix_la_CFLAGS	= $(DYNAMIC)
+pam_unix_la_CFLAGS	= $(LIBSELINUX_DEFS) $(DYNAMIC)
 
 if DYNAMIC_MODULES
 modules_LTLIBRARIES	= pam_unix.la
@@ -25,15 +33,15 @@
 
 if NSLLIB_PRESENT
 if CRACKLIB_PRESENT
-pam_unix_la_LIBADD	= -lnsl -lcrack ../../pamcrypt/libpamcrypt.la
+pam_unix_la_LIBADD	= -lnsl -lcrack $(LIBSELINUX) ../../pamcrypt/libpamcrypt.la
 else
-pam_unix_la_LIBADD	= -lnsl ../../pamcrypt/libpamcrypt.la
+pam_unix_la_LIBADD	= -lnsl $(LIBSELINUX) ../../pamcrypt/libpamcrypt.la
 endif
 else
 if CRACKLIB_PRESENT
-pam_unix_la_LIBADD	= -lcrack ../../pamcrypt/libpamcrypt.la
+pam_unix_la_LIBADD	= -lcrack $(LIBSELINUX) ../../pamcrypt/libpamcrypt.la
 else
-pam_unix_la_LIBADD	= ../../pamcrypt/libpamcrypt.la
+pam_unix_la_LIBADD	= $(LIBSELINUX) ../../pamcrypt/libpamcrypt.la
 endif
 endif
 
@@ -42,7 +50,8 @@
 sbin_PROGRAMS		= unix_chkpwd
 
 unix_chkpwd_SOURCES	= unix_chkpwd.c
-unix_chkpwd_LDADD	= ../../pamcrypt/libpamcrypt.la
+unix_chkpwd_CFLAGS	= $(LIBSELINUX_DEFS)
+unix_chkpwd_LDADD	= $(LIBSELINUX) ../../pamcrypt/libpamcrypt.la
 
 EXTRA_DIST		= README CHANGELOG
 
diff -urN pam-pld-0.77.3.org/modules/pam_unix/pam_unix_acct.c pam-pld-0.77.3/modules/pam_unix/pam_unix_acct.c
--- pam-pld-0.77.3.org/modules/pam_unix/pam_unix_acct.c	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/pam_unix_acct.c	2003-12-27 01:14:20.000000000 +0100
@@ -44,6 +44,15 @@
 #include <pwd.h>
 #include <shadow.h>
 #include <time.h>		/* for time() */
+#include <linux/limits.h>
+#include <errno.h>
+#include <sys/wait.h>
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#define SELINUX_ENABLED is_selinux_enabled()
+#else
+#define SELINUX_ENABLED 0
+#endif
 
 
 #include "security/_pam_macros.h"
@@ -59,7 +68,110 @@
 #endif				/* LINUX_PAM */
 
 #include "support.h"
+struct spwd spwd;
  
+struct spwd *_unix_run_verify_binary(pam_handle_t *pamh, unsigned int ctrl, const char *user)
+{
+  int retval=0, child, fds[2];
+  void (*sighandler)(int) = NULL;
+  D(("running verify_binary"));
+
+  /* create a pipe for the messages */
+  if (pipe(fds) != 0) {
+    D(("could not make pipe"));
+    _log_err(LOG_ERR, pamh, "Could not make pipe %s",strerror(errno));
+    return NULL;
+  }
+  D(("called."));
+  
+  if (off(UNIX_NOREAP, ctrl)) {
+    /*
+     * This code arranges that the demise of the child does not cause
+     * the application to receive a signal it is not expecting - which
+     * may kill the application or worse.
+     *
+     * The "noreap" module argument is provided so that the admin can
+     * override this behavior.
+     */
+    sighandler = signal(SIGCHLD, SIG_DFL);
+  }
+
+  /* fork */
+  child = fork();
+  if (child == 0) {
+    int i=0;
+    struct rlimit rlim;
+    static char *envp[] = { NULL };
+    char *args[] = { NULL, NULL, NULL, NULL };
+
+    close(0); close(1);
+    /* reopen stdin as pipe */
+    close(fds[0]);
+    dup2(fds[1], STDOUT_FILENO);
+    
+    /* XXX - should really tidy up PAM here too */
+    
+    if (getrlimit(RLIMIT_NOFILE,&rlim)==0) {
+      for (i=2; i < rlim.rlim_max; i++) {
+	if (fds[1] != i) {
+	  close(i);
+	}
+      }	
+    }
+    /* exec binary helper */
+    args[0] = x_strdup(CHKPWD_HELPER);
+    args[1] = x_strdup(user);
+    args[2] = x_strdup("verify");
+    
+    execve(CHKPWD_HELPER, args, envp);
+    
+    _log_err(LOG_ERR, pamh, "execve failed: %s",strerror(errno));
+    /* should not get here: exit with error */
+    D(("helper binary is not available"));
+    exit(PAM_AUTHINFO_UNAVAIL);
+  } else { 
+    if (child > 0) {
+      char buf[1024];
+      int rc=0;
+      rc = read(fds[0], buf, sizeof(buf) - 1);
+      if(rc > 0)
+	{
+	  buf[rc] = '\0';
+	  sscanf(buf,"%ld:%ld:%ld:%ld:%ld:%ld",
+		 &spwd.sp_lstchg, /* last password change */
+                 &spwd.sp_min, /* days until change allowed. */
+                 &spwd.sp_max, /* days before change required */
+                 &spwd.sp_warn, /* days warning for expiration */
+                 &spwd.sp_inact, /* days before account inactive */
+                 &spwd.sp_expire); /* date when account expires */
+	}		
+      else {
+	_log_err(LOG_ERR, pamh, " ERROR %d:%s \n",rc, strerror(errno));
+      }
+      close(fds[1]);
+      close(fds[0]);
+      rc=waitpid(child, &retval, 0);  /* wait for helper to complete */
+      if (rc<0) {
+	_log_err(LOG_ERR, pamh, "unix_chkpwd waitpid returned %d: %s", rc, strerror(errno));
+	retval = PAM_AUTH_ERR;
+      } else {
+	retval = WEXITSTATUS(retval);
+      }
+    } else {
+      D(("fork failed"));
+      close(fds[0]);close(fds[1]);
+      retval = PAM_AUTH_ERR;
+    }
+  }
+  if (sighandler != NULL) {
+    (void) signal(SIGCHLD, sighandler);   /* restore old signal handler */
+  }
+  D(("Returning %d",retval));
+  if (retval != PAM_SUCCESS) {
+    return NULL;
+  } 
+  return &spwd;
+}	
 /*
  * PAM framework looks for this entry-point to pass control to the
  * account management module.
@@ -128,6 +240,9 @@
 		return PAM_SUCCESS;
 	}
 
+	if (!spent && SELINUX_ENABLED ) 
+	    spent = _unix_run_verify_binary(pamh, ctrl, uname);
+
 	if (!spent)
 		return PAM_AUTHINFO_UNAVAIL;	/* Couldn't get username from shadow */
 
diff -urN pam-pld-0.77.3.org/modules/pam_unix/pam_unix_passwd.c pam-pld-0.77.3/modules/pam_unix/pam_unix_passwd.c
--- pam-pld-0.77.3.org/modules/pam_unix/pam_unix_passwd.c	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/pam_unix_passwd.c	2003-12-27 03:09:39.984026744 +0100
@@ -56,7 +56,18 @@
 #include <rpc/rpc.h>
 #include <rpcsvc/yp_prot.h>
 #include <rpcsvc/ypclnt.h>
-
+#include <signal.h>
+#include <linux/limits.h>
+#include <sys/wait.h>
+static int selinux_enabled=-1;
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+static security_context_t prev_context=NULL;
+#define SELINUX_ENABLED (selinux_enabled != -1 ? selinux_enabled : selinux_enabled=is_selinux_enabled())
+#else
+#define SELINUX_ENABLED 0
+#endif
+    
 #ifdef HAVE_CRACK_H
 #include <crack.h>
 #endif
@@ -260,6 +271,97 @@
 	return master;
 }
 
+static int _unix_run_shadow_binary(pam_handle_t *pamh, unsigned int ctrl, const char *user, const char *fromwhat, const char *towhat)
+{
+    int retval, child, fds[2];
+    void (*sighandler)(int) = NULL;
+
+    D(("called."));
+    /* create a pipe for the password */
+    if (pipe(fds) != 0) {
+	D(("could not make pipe"));
+	return PAM_AUTH_ERR;
+    }
+
+    if (off(UNIX_NOREAP, ctrl)) {
+	/*
+	 * This code arranges that the demise of the child does not cause
+	 * the application to receive a signal it is not expecting - which
+	 * may kill the application or worse.
+	 *
+	 * The "noreap" module argument is provided so that the admin can
+	 * override this behavior.
+	 */
+	sighandler = signal(SIGCHLD, SIG_DFL);
+    }
+
+    /* fork */
+    child = fork();
+    if (child == 0) {
+        int i=0;
+        struct rlimit rlim;
+	static char *envp[] = { NULL };
+	char *args[] = { NULL, NULL, NULL, NULL };
+
+	/* XXX - should really tidy up PAM here too */
+
+	close(0); close(1);
+	/* reopen stdin as pipe */
+	close(fds[1]);
+	dup2(fds[0], STDIN_FILENO);
+
+	if (getrlimit(RLIMIT_NOFILE,&rlim)==0) {
+	  for (i=2; i < rlim.rlim_max; i++) {
+		if (fds[0] != i)
+	  	   close(i);
+	  }	
+	}
+	/* exec binary helper */
+	args[0] = x_strdup(CHKPWD_HELPER);
+	args[1] = x_strdup(user);
+	args[2] = x_strdup("shadow");
+
+	execve(CHKPWD_HELPER, args, envp);
+
+	/* should not get here: exit with error */
+	D(("helper binary is not available"));
+	exit(PAM_AUTHINFO_UNAVAIL);
+    } else if (child > 0) {
+	/* wait for child */
+	/* if the stored password is NULL */
+        int rc=0;
+	if (fromwhat) 
+	  write(fds[1], fromwhat, strlen(fromwhat)+1);
+	else
+	  write(fds[1], "", 1);
+	if (towhat) {
+	  write(fds[1], towhat, strlen(towhat)+1);
+	}
+	else
+	  write(fds[1], "", 1);
+
+	close(fds[0]);       /* close here to avoid possible SIGPIPE above */
+	close(fds[1]);
+	rc=waitpid(child, &retval, 0);  /* wait for helper to complete */
+	if (rc<0) {
+	  _log_err(LOG_ERR, pamh, "unix_chkpwd waitpid returned %d: %s", rc, strerror(errno));
+	  retval = PAM_AUTH_ERR;
+	} else {
+	  retval = WEXITSTATUS(retval);
+	}
+    } else {
+	D(("fork failed"));
+	close(fds[0]);
+ 	close(fds[1]);
+	retval = PAM_AUTH_ERR;
+    }
+
+    if (sighandler != NULL) {
+        (void) signal(SIGCHLD, sighandler);   /* restore old signal handler */
+    }
+
+    return retval;
+}
 static int check_old_password(const char *forwho, const char *newpass)
 {
 	static char buf[16384];
@@ -318,16 +420,41 @@
     }
 
 	oldmask = umask(077);
+	
+	if (SELINUX_ENABLED) {
+		security_context_t passwd_context = NULL;
+		
+		if (getfilecon("/etc/passwd",&passwd_context) < 0) {
+			return PAM_AUTHTOK_ERR;
+		}
+		
+		if (getfscreatecon(&prev_context)<0) {
+			freecon(passwd_context);
+			return PAM_AUTHTOK_ERR;
+		}
+		
+		if (setfscreatecon(passwd_context)) {
+			freecon(passwd_context);
+			freecon(prev_context);
+			return PAM_AUTHTOK_ERR;
+		}
+		
+		freecon(passwd_context);
+	}
+
 	pwfile = fopen(OPW_TMPFILE, "w");
 	umask(oldmask);
-    if (pwfile == NULL) {
-		return PAM_AUTHTOK_ERR;
-    }
+    
+	if (pwfile == NULL) {
+	    err = 1;
+	    goto done;
+    	}
 
 	opwfile = fopen(OLD_PASSWORDS_FILE, "r");
 	if (opwfile == NULL) {
-		fclose(pwfile);
-		return PAM_AUTHTOK_ERR;
+	    	fclose(pwfile);
+	    	err=1;
+		goto done;
 	}
 
 	chown(OPW_TMPFILE, 0, 0);
@@ -388,8 +515,20 @@
 		err = 1;
 	}
 
-	if (!err) {
+done:
+	if (!err)
 		rename(OPW_TMPFILE, OLD_PASSWORDS_FILE);
+#ifdef WITH_SELINUX
+	if (SELINUX_ENABLED) {
+	    if (setfscreatecon(prev_context)) {
+		err = 1;
+	    }
+	    if (prev_context)
+		freecon(prev_context);
+	    prev_context=NULL;
+	}
+#endif
+	if (!err) {
 		return PAM_SUCCESS;
 	} else {
 		unlink(OPW_TMPFILE);
@@ -406,16 +545,36 @@
 	int oldmask;
 
 	oldmask = umask(077);
+#ifdef WITH_SELINUX
+   	if (SELINUX_ENABLED) {
+     	    security_context_t passwd_context=NULL;
+     	    if (getfilecon("/etc/passwd",&passwd_context)<0) {
+	 	return PAM_AUTHTOK_ERR;
+     	    };
+     	    if (getfscreatecon(&prev_context)<0) {
+	 	freecon(passwd_context);
+	 	return PAM_AUTHTOK_ERR;
+     	    }
+     	    if (setfscreatecon(passwd_context)) {
+	 	freecon(passwd_context);
+	 	freecon(prev_context);
+	 	return PAM_AUTHTOK_ERR;
+	    }
+     	    freecon(passwd_context);
+   	}
+#endif
 	pwfile = fopen(PW_TMPFILE, "w");
 	umask(oldmask);
-    if (pwfile == NULL) {
-		return PAM_AUTHTOK_ERR;
-    }
+    	if (pwfile == NULL) {
+	    	err=1;
+		goto done;
+    	}
 
 	opwfile = fopen("/etc/passwd", "r");
 	if (opwfile == NULL) {
-		fclose(pwfile);
-		return PAM_AUTHTOK_ERR;
+	    	fclose(pwfile);       
+		err = 1;
+		goto done;
 	}
 
 	chown(PW_TMPFILE, 0, 0);
@@ -447,9 +606,22 @@
 		err = 1;
 	}
 
+done:
 	if (!err) {
 		rename(PW_TMPFILE, "/etc/passwd");
 		_log_err(LOG_NOTICE, pamh, "password changed for %s", forwho);
+	}
+#ifdef WITH_SELINUX
+	if (SELINUX_ENABLED) {
+	    if (setfscreatecon(prev_context)) {
+		err = 1;
+	    }
+	    if (prev_context)
+		freecon(prev_context);
+	    prev_context=NULL;
+	}
+#endif
+	if (!err) {
 		return PAM_SUCCESS;
 	} else {
 		unlink(PW_TMPFILE);
@@ -465,20 +637,43 @@
 	int oldmask;
 
 	spwdent = getspnam(forwho);
-    if (spwdent == NULL) {
-		return PAM_USER_UNKNOWN;
-    }
+
+	if (spwdent == NULL) {
+	    return PAM_USER_UNKNOWN;
+     	}
+	
 	oldmask = umask(077);
+#ifdef WITH_SELINUX
+   	if (SELINUX_ENABLED) {
+     	    security_context_t shadow_context=NULL;
+     	    if (getfilecon("/etc/shadow",&shadow_context)<0) {
+	 	return PAM_AUTHTOK_ERR;
+     	    };
+     	    if (getfscreatecon(&prev_context)<0) {
+	 	freecon(shadow_context);
+	 	return PAM_AUTHTOK_ERR;
+     	    }
+     	    if (setfscreatecon(shadow_context)) {
+	 	freecon(shadow_context);
+	 	freecon(prev_context);
+	 	return PAM_AUTHTOK_ERR;
+     	    }
+     	    freecon(shadow_context);
+   	}
+#endif
 	pwfile = fopen(SH_TMPFILE, "w");
 	umask(oldmask);
-    if (pwfile == NULL) {
-		return PAM_AUTHTOK_ERR;
-    }
+	
+	if (pwfile == NULL) {
+     	    err = 1;
+     	    goto done;
+    	}
 
 	opwfile = fopen("/etc/shadow", "r");
 	if (opwfile == NULL) {
 		fclose(pwfile);
-		return PAM_AUTHTOK_ERR;
+	 	err = 1;
+	 	goto done;
 	}
 
 	chown(SH_TMPFILE, 0, 0);
@@ -508,8 +703,22 @@
 		err = 1;
 	}
 
+done:
 	if (!err) {
 		rename(SH_TMPFILE, "/etc/shadow");
+	}
+#ifdef WITH_SELINUX
+   	if (SELINUX_ENABLED) {
+     	    if (setfscreatecon(prev_context)) {
+	 	err = 1;
+     	    }
+     	    if (prev_context)
+	 	freecon(prev_context);
+     	    prev_context=NULL;
+   	}
+#endif
+    
+	if (!err) {
 		return PAM_SUCCESS;
 	} else {
 		unlink(SH_TMPFILE);
@@ -600,6 +809,8 @@
 	}
 	if (on(UNIX_SHADOW, ctrl) || (strcmp(pwd->pw_passwd, "x") == 0)) {
 		retval = _update_shadow(forwho, towhat);
+		if (retval != PAM_SUCCESS && SELINUX_ENABLED)
+			retval = _unix_run_shadow_binary(pamh, ctrl, forwho, fromwhat, towhat);
 		if (retval == PAM_SUCCESS)
 			retval = _update_passwd(pamh, forwho, "x");
 	} else {
@@ -609,7 +820,7 @@
 	return retval;
 }
 
-static int _unix_verify_shadow(const char *user, unsigned int ctrl)
+static int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned int ctrl)
 {
 	struct passwd *pwd = NULL;	/* Password and shadow password */
 	struct spwd *spwdent = NULL;	/* file entries for the user */
@@ -630,6 +841,8 @@
 		spwdent = getspnam(user);
 		endspent();
 
+		if (spwdent == NULL && SELINUX_ENABLED ) 
+		    spwdent = _unix_run_verify_binary(pamh, ctrl, user);
 		if (spwdent == NULL)
 			return PAM_AUTHINFO_UNAVAIL;
 	} else {
@@ -877,7 +1090,7 @@
 			_log_err(LOG_CRIT, pamh,
 			         "failed to set PAM_OLDAUTHTOK");
 		}
-		retval = _unix_verify_shadow(user, ctrl);
+		retval = _unix_verify_shadow(pamh,user, ctrl);
 		if (retval == PAM_AUTHTOK_ERR) {
 			if (off(UNIX__IAMROOT, ctrl))
 				_make_remark(pamh, ctrl, PAM_ERROR_MSG,
@@ -926,7 +1139,7 @@
 #endif
 			return retval;
 		}
-		retval = _unix_verify_shadow(user, ctrl);
+		retval = _unix_verify_shadow(pamh, user, ctrl);
 		if (retval != PAM_SUCCESS) {
 			_log_err(LOG_NOTICE, pamh, "user not authenticated 2");
 #ifdef USE_LCKPWDF
diff -urN pam-pld-0.77.3.org/modules/pam_unix/support.c pam-pld-0.77.3/modules/pam_unix/support.c
--- pam-pld-0.77.3.org/modules/pam_unix/support.c	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/support.c	2003-12-27 03:10:49.073523544 +0100
@@ -13,11 +13,18 @@
 #include <pwd.h>
 #include <shadow.h>
 #include <limits.h>
+#include <linux/limits.h>
 #include <utmp.h>
 #include <errno.h>
 #include <crypt.h>
 #include <signal.h>
-
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#define SELINUX_ENABLED is_selinux_enabled()
+#else
+#define SELINUX_ENABLED 0
+#endif
+    
 #include "security/_pam_macros.h"
 #include "security/pam_modules.h"
 
@@ -464,18 +471,32 @@
     /* fork */
     child = fork();
     if (child == 0) {
+        int i=0;
+        struct rlimit rlim;
 	static char *envp[] = { NULL };
-	char *args[] = { NULL, NULL, NULL };
+	char *args[] = { NULL, NULL, NULL, NULL };
 
 	/* XXX - should really tidy up PAM here too */
 
+	close(0); close(1);
 	/* reopen stdin as pipe */
 	close(fds[1]);
 	dup2(fds[0], STDIN_FILENO);
 
+	if (getrlimit(RLIMIT_NOFILE,&rlim)==0) {
+	  for (i=2; i < rlim.rlim_max; i++) {
+		if (fds[0] != i)
+	  	   close(i);
+	  }	
+	}
 	/* exec binary helper */
 	args[0] = x_strdup(CHKPWD_HELPER);
 	args[1] = x_strdup(user);
+	if (off(UNIX__NONULL, ctrl)) {	/* this means we've succeeded */
+	  args[2]=x_strdup("nullok");
+	} else {
+	  args[2]=x_strdup("nonull");
+	}
 
 	execve(CHKPWD_HELPER, args, envp);
 
@@ -485,11 +506,7 @@
     } else if (child > 0) {
 	/* wait for child */
 	/* if the stored password is NULL */
-	if (off(UNIX__NONULL, ctrl)) {	/* this means we've succeeded */
-	    write(fds[1], "nullok\0\0", 8);
-	} else {
-	    write(fds[1], "nonull\0\0", 8);
-	}
+        int rc=0;
 	if (passwd != NULL) {            /* send the password to the child */
 	    write(fds[1], passwd, strlen(passwd)+1);
 	    passwd = NULL;
@@ -498,10 +515,17 @@
 	}
 	close(fds[0]);       /* close here to avoid possible SIGPIPE above */
 	close(fds[1]);
-	(void) waitpid(child, &retval, 0);  /* wait for helper to complete */
-	retval = (retval == 0) ? PAM_SUCCESS:PAM_AUTH_ERR;
+	rc=waitpid(child, &retval, 0);  /* wait for helper to complete */
+	if (rc<0) {
+	  _log_err(LOG_ERR, pamh, "unix_chkpwd waitpid returned %d: %s", rc, strerror(errno));
+	  retval = PAM_AUTH_ERR;
+	} else {
+	  retval = WEXITSTATUS(retval);
+	}
     } else {
 	D(("fork failed"));
+	close(fds[0]);
+ 	close(fds[1]);
 	retval = PAM_AUTH_ERR;
     }
 
@@ -523,6 +547,7 @@
 	char *data_name;
 	int retval;
 
+
 	D(("called"));
 
 #ifdef HAVE_PAM_FAIL_DELAY
@@ -589,7 +614,7 @@
 
 	retval = PAM_SUCCESS;
 	if (pwd == NULL || salt == NULL || !strcmp(salt, "x")) {
-		if (geteuid()) {
+		if (geteuid() || SELINUX_ENABLED) {
 			/* we are not root perhaps this is the reason? Run helper */
 			D(("running helper binary"));
 			retval = _unix_run_helper_binary(pamh, p, ctrl, name);
diff -urN pam-pld-0.77.3.org/modules/pam_unix/support.h pam-pld-0.77.3/modules/pam_unix/support.h
--- pam-pld-0.77.3.org/modules/pam_unix/support.h	2003-12-27 01:14:07.000000000 +0100
+++ pam-pld-0.77.3/modules/pam_unix/support.h	2003-12-27 01:14:20.000000000 +0100
@@ -147,5 +147,6 @@
 			,const char *data_name
 			,const char **pass);
 
+extern struct spwd *_unix_run_verify_binary(pam_handle_t *pamh, unsigned int ctrl, const char *user);
 #endif /* _PAM_UNIX_SUPPORT_H */
 
--- pam-pld-0.77.3/modules/pam_unix/unix_chkpwd.c.orig	Fri Sep 26 13:30:16 2003
+++ pam-pld-0.77.3/modules/pam_unix/unix_chkpwd.c	Tue Jan 27 11:44:02 2004
@@ -27,13 +27,24 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <pwd.h>
 #include <shadow.h>
 #include <signal.h>
 #include <crypt.h>
-
+#include <time.h>
+static int selinux_enabled=-1;
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#define SELINUX_ENABLED (selinux_enabled!=-1 ? selinux_enabled : selinux_enabled=is_selinux_enabled())
+static security_context_t prev_context=NULL;
+#else
+#define SELINUX_ENABLED 0
+#endif
+    
 #define MAXPASS		200	/* the maximum length of a password */
 
+#include <security/_pam_types.h>
 #include "security/_pam_macros.h"
 
 #include "pam_crypt.h"
@@ -86,6 +97,33 @@
 	(void) sigaction(SIGQUIT, &action, NULL);
 }
 
+static int _verify_account(const char * const uname)
+{
+	struct spwd *spent;
+	struct passwd *pwent;
+   
+	pwent = getpwnam(uname);
+  	if (!pwent) {
+	    _log_err(LOG_ALERT, "could not identify user (from getpwnam(%s))", uname);
+	    return PAM_USER_UNKNOWN;
+  	}
+  
+	spent = getspnam( uname );
+	if (!spent) {
+	    _log_err(LOG_ALERT, "could not get username from shadow (%s))", uname);
+	    return PAM_AUTHINFO_UNAVAIL;    /* Couldn't get username from shadow */
+  	}
+  	printf("%ld:%ld:%ld:%ld:%ld:%ld",
+ 		spent->sp_lstchg, /* last password change */
+		spent->sp_min, /* days until change allowed. */
+		spent->sp_max, /* days before change required */
+		spent->sp_warn, /* days warning for expiration */
+		spent->sp_inact, /* days before account inactive */
+		spent->sp_expire); /* date when account expires */
+	
+	return PAM_SUCCESS;
+}
+
 static int _unix_verify_password(const char *name, const char *p, int opt)
 {
 	struct passwd *pwd = NULL;
@@ -223,11 +261,171 @@
 	return username;
 }
 
+ #define SH_TMPFILE            "/etc/nshadow"
+ static int _update_shadow(const char *forwho)
+ {
+     struct spwd *spwdent = NULL, *stmpent = NULL;
+     FILE *pwfile, *opwfile;
+     int err = 1;
+     int oldmask;
+     struct stat st;
+     char pass[MAXPASS + 1];
+     char towhat[MAXPASS + 1];
+     int npass=0;
+
+     /* read the password from stdin (a pipe from the pam_unix module) */
+
+     npass = read(STDIN_FILENO, pass, MAXPASS);
+
+     if (npass < 0) {  /* is it a valid password? */
+
+       _log_err(LOG_DEBUG, "no password supplied");
+       return PAM_AUTHTOK_ERR;
+
+     } else if (npass >= MAXPASS) {
+
+       _log_err(LOG_DEBUG, "password too long");
+       return PAM_AUTHTOK_ERR;
+
+     } else {
+       /* does pass agree with the official one? */
+       int retval=0;
+       pass[npass] = '\0';     /* NUL terminate */
+       retval = _unix_verify_password(forwho, pass, 0);
+       if (retval != PAM_SUCCESS) {
+       return retval;
+       }
+     }
+
+     /* read the password from stdin (a pipe from the pam_unix module) */
+
+     npass = read(STDIN_FILENO, towhat, MAXPASS);
+
+     if (npass < 0) {  /* is it a valid password? */
+
+       _log_err(LOG_DEBUG, "no new password supplied");
+       return PAM_AUTHTOK_ERR;
+
+     } else if (npass >= MAXPASS) {
+
+       _log_err(LOG_DEBUG, "new password too long");
+       return PAM_AUTHTOK_ERR;
+
+     }
+
+     towhat[npass] = '\0';     /* NUL terminate */
+     spwdent = getspnam(forwho);
+     if (spwdent == NULL) {
+       return PAM_USER_UNKNOWN;
+     }
+     oldmask = umask(077);
+
+ #ifdef WITH_SELINUX
+     if (SELINUX_ENABLED) {
+       security_context_t shadow_context=NULL;
+       if (getfilecon("/etc/shadow",&shadow_context)<0) {
+       return PAM_AUTHTOK_ERR;
+       };
+       if (getfscreatecon(&prev_context)<0) {
+       freecon(shadow_context);
+       return PAM_AUTHTOK_ERR;
+       }
+       if (setfscreatecon(shadow_context)) {
+       freecon(shadow_context);
+       freecon(prev_context);
+       return PAM_AUTHTOK_ERR;
+       }
+       freecon(shadow_context);
+     }
+ #endif
+     pwfile = fopen(SH_TMPFILE, "w");
+     umask(oldmask);
+     if (pwfile == NULL) {
+       err = 1;
+       goto done;
+     }
+
+     opwfile = fopen("/etc/shadow", "r");
+     if (opwfile == NULL) {
+       fclose(pwfile);
+       err = 1;
+       goto done;
+     }
+
+     if (fstat(fileno(opwfile), &st) == -1) {
+       fclose(opwfile);
+       fclose(pwfile);
+       err = 1;
+       goto done;
+     }
+
+     if (fchown(fileno(pwfile), st.st_uid, st.st_gid) == -1) {
+       fclose(opwfile);
+       fclose(pwfile);
+       err = 1;
+       goto done;
+     }
+     if (fchmod(fileno(pwfile), st.st_mode) == -1) {
+       fclose(opwfile);
+       fclose(pwfile);
+       err = 1;
+       goto done;
+     }
+     stmpent = fgetspent(opwfile);
+     while (stmpent) {
+
+       if (!strcmp(stmpent->sp_namp, forwho)) {
+           stmpent->sp_pwdp = towhat;
+           stmpent->sp_lstchg = time(NULL) / (60 * 60 * 24);
+           err = 0;
+           D(("Set password %s for %s", stmpent->sp_pwdp, forwho));
+       }
+
+       if (putspent(stmpent, pwfile)) {
+           D(("error writing entry to shadow file: %s\n", strerror(errno)));
+           err = 1;
+           break;
+       }
+
+       stmpent = fgetspent(opwfile);
+     }
+     fclose(opwfile);
+
+     if (fclose(pwfile)) {
+       D(("error writing entries to shadow file: %s\n", strerror(errno)));
+       err = 1;
+     }
+
+  done:
+     if (!err) {
+       rename(SH_TMPFILE, "/etc/shadow");
+     }
+
+ #ifdef WITH_SELINUX
+     if (SELINUX_ENABLED) {
+       if (setfscreatecon(prev_context)) {
+       err = 1;
+       }
+       if (prev_context)
+       freecon(prev_context);
+       prev_context=NULL;
+     }
+ #endif
+
+     if (!err) {
+       return PAM_SUCCESS;
+     } else {
+       unlink(SH_TMPFILE);
+       return PAM_AUTHTOK_ERR;
+     }
+ }
+
+
 int main(int argc, char *argv[])
 {
 	char pass[MAXPASS + 1];
-	char option[8];
 	int npass, opt;
+	char *option;
 	int force_failure = 0;
 	int retval = UNIX_FAILED;
 	char *user;
@@ -246,8 +444,7 @@
 	 * account).
 	 */
 
-	if (isatty(STDIN_FILENO)) {
-
+	if (isatty(STDIN_FILENO) || argc != 3) {
 		_log_err(LOG_NOTICE
 		      ,"inappropriate use of Unix helper binary [UID=%d]"
 			 ,getuid());
@@ -259,32 +456,41 @@
 	}
 
 	/*
-	 * determine the current user's name is
+	 * determine the current user's name is.
+	 * On a SELinux enabled system, policy will prevent third parties from using
+	 * unix_chkpwd as a password guesser.  Leaving the existing check prevents
+	 * su from working,  Since the current uid is the users and the password is
+	 * for root.
 	 */
-	user = getuidname(getuid());
-	if (argc == 2) {
-	    /* if the caller specifies the username, verify that user
-	       matches it */
-	    if (strcmp(user, argv[1])) {
-		force_failure = 1;
-	    }
+	if (SELINUX_ENABLED) {
+	  user=argv[1];
+	}
+	else {
+	  user = getuidname(getuid());
+	  /* if the caller specifies the username, verify that user
+	     matches it */
+	  if (strcmp(user, argv[1])) {
+	    force_failure = 1;
+	  }
 	}
 
-	/* read the nullok/nonull option */
-
-	npass = read(STDIN_FILENO, option, 8);
+	option=argv[2];
+	if (strncmp(argv[2], "verify", 8) == 0) {
+		/* Get the account information from the shadow file */
+		return _verify_account(argv[1]);
+	}
 
-	if (npass < 0) {
-		_log_err(LOG_DEBUG, "no option supplied");
-		return UNIX_FAILED;
-	} else {
-		option[7] = '\0';
-		if (strncmp(option, "nullok", 8) == 0)
-			opt = 1;
-		else
-			opt = 0;
+	if (strncmp(option, "shadow", 8) == 0) {
+		/* Attempting to change the password */
+		return _update_shadow(argv[1]);
 	}
 
+        /* read the nullok/nonull option */
+	if (strncmp(option, "nullok", 8) == 0)
+		opt = 1;
+	else
+		opt = 0;
+
 	/* read the password from stdin (a pipe from the pam_unix module) */
 
 	npass = read(STDIN_FILENO, pass, MAXPASS);
